{"run":{"modified_at":"2026-01-01T18:40:25.743142Z","run_id":"trun_4670f7ad5ac840b6bdd8f00e9c296d5d","is_active":false,"status":"completed","processor":"pro","metadata":{},"created_at":"2026-01-01T18:30:46.846672Z"},"output":{"content":"# Taming Clojure in Production: 8 Hidden Cost Centers You Can Fix This Quarter\n\n## Executive Summary\n\nClojure's power in development can introduce subtle but significant operational pain points in production. These challenges, from cryptic error messages to hidden memory leaks, often manifest as increased mean time to resolution (MTTR), degraded performance, and bloated deployment artifacts. This report analyzes the eight most critical production pain points and provides a playbook of actionable, evidence-backed strategies to mitigate them. By implementing targeted tooling and best practices, teams can drastically improve the stability, performance, and maintainability of their Clojure applications.\n\n### Cryptic Stack Traces Inflate Debugging Time\nJVM stack traces in Clojure are notoriously noisy, often obscured by Java internals, macro expansions, and missing line numbers. This lack of clarity directly inflates debugging time. A failed namespace reload, for instance, can wipe the REPL's state, forcing a full, time-consuming JVM restart to recover [1]. **Adopting libraries like `io.aviso/pretty` and standardizing on data-rich `ex-info` exceptions can cut diagnostic cycles significantly.**\n\n### Unhinted Java Interop Creates Performance Hotspots\nThe Clojure compiler's reliance on Java reflection for unhinted interop calls is a primary source of performance degradation. In performance-critical hot paths, a single unhinted call can be orders of magnitude slower—benchmarks show a call to `.charAt` dropping from **4.8 microseconds** to just **12.4 nanoseconds** with a simple `^String` type hint [2]. **Enabling `*warn-on-reflection*` in CI pipelines and strategically applying type hints to the most frequently called functions is the highest-leverage performance optimization available.**\n\n### Lazy Sequences Mask Catastrophic Memory Leaks\nClojure's laziness is powerful but perilous. Lazy sequences can unintentionally retain references to the entire sequence head, leading to major memory leaks that are difficult to diagnose. Benchmarks are easily fooled; one test showed a `map` operation seemingly taking **16 nanoseconds**, but forcing the lazy sequence's realization with `doall` revealed the true cost to be **~300 microseconds**—a nearly **18,000-fold** difference [3]. **During performance tuning, always force sequence realization and use allocation profilers like `clj-async-profiler` to uncover the true memory cost.**\n\n### JVM Cold Starts Hinder Serverless and CLI Adoption\nThe JVM's startup time remains a significant barrier for latency-sensitive applications like serverless functions and command-line tools. While GraalVM native images can dramatically reduce startup times, they introduce build complexity and limit dynamic features. **A hybrid strategy is most effective: use lightweight runtimes like Babashka for simple scripts, reserve GraalVM for critical serverless functions, and leverage JVM features like Application Class-Data Sharing (AppCDS) for traditional services.**\n\n### Fragile Reload Workflows Waste Developer Hours\nThe default REPL workflow using `tools.namespace` is prone to failure. A partial or failed code reload can leave the system in an inconsistent state, losing handles to resources like database connections or sockets and forcing a manual restart [1] [4]. **Migrating to robust state-management libraries like Integrant or Mount, which provide reliable `start`, `stop`, and `reset` lifecycles, is essential for productive, REPL-driven development [5] [6] [7].**\n\n### Dependency Conflicts and Bloat Inflate Artifacts\nWithout disciplined management, Clojure projects accumulate conflicting and unnecessary dependencies, leading to bloated uberjars and classpath hell. It's common for projects to have multiple versions of the same library pulled in transitively or defined in separate configuration files like `deps.edn` and `shadow-cljs.edn` [8]. **Implementing a CI step with tools like `antq` to detect outdated libraries and using `tools.deps`'s `:override-deps` feature can systematically shrink artifact size and prevent runtime errors.**\n\n### Profiling Is Underutilized Despite Low Overhead\nMany teams avoid production profiling, fearing performance degradation. However, modern tools like `clj-async-profiler` have a negligible single-digit percentage overhead, making them safe for production use [9]. This tool can quickly identify CPU bottlenecks, memory allocation hotspots, and lock contention issues through intuitive flame graphs, offering significant optimization wins for minimal effort [2] [9].\n\n## 1. Error Observability: From Cryptic to Clear\n\nThe default Clojure error reporting experience in production is a significant source of friction. Cryptic stack traces from the JVM, combined with information loss from macro expansion, make root cause analysis slow and frustrating.\n\n### 1.1. The Problem with Default JVM Stack Traces\nStandard JVM stack traces are verbose and difficult to parse for Clojure code. They are filled with Java internals and mangled function names, hiding the actual point of failure within the Clojure source. This forces developers to manually sift through dozens of irrelevant lines to find the actionable information.\n\n### 1.2. Enhancing Readability with Tooling\nTo combat this, teams should mandate the use of a stack trace formatting library.\n* **`io.aviso/pretty` or `clojure.stacktrace`**: These libraries reformat stack traces to be more human-readable, filtering out Java noise and highlighting the Clojure-specific parts of the call stack.\n* **`ex-info` with Data**: The standard for signaling errors should be `ex-info`, which allows arbitrary data maps to be attached to an exception. A team-wide convention to always include the namespace and line number can provide crucial context that is often lost.\n* **Logging with MDC**: Integrating with a logging library that supports Mapped Diagnostic Context (MDC), such as `tools.logging`, allows you to inject contextual data (e.g., request ID, user ID) into every log statement, making it possible to trace a single request's lifecycle through the system.\n\n### 1.3. Debugging in the REPL\nThe REPL itself offers powerful debugging capabilities. The special variable `*e` holds the last exception, allowing for immediate inspection. Running `(pst *e)` will print the formatted stack trace of the most recent error, providing a quick feedback loop during development [5].\n\n## 2. Startup Time & Memory: Winning the Cold Start Battle\n\nJVM cold start times and memory footprint are critical concerns for serverless architectures, CLI tools, and containerized environments with aggressive scaling. A standard Clojure application can take over a second to start, which is often unacceptable.\n\n### 2.1. Comparing Startup Strategies\nThere is no one-size-fits-all solution; the right approach depends on the specific use case, balancing startup speed, build complexity, and runtime flexibility.\n\n| Strategy | Typical Startup Time | Build Complexity | Runtime Limitations | Best For |\n| :--- | :--- | :--- | :--- | :--- |\n| **Standard JVM** | > 1 second | Low | None | Traditional, long-running services |\n| **JVM + AppCDS** | 500-800 ms | Medium | None | Services with frequent restarts |\n| **GraalVM Native Image** | 20-100 ms | High | No dynamic class loading, reflection needs configuration | Latency-critical serverless functions, CLIs |\n| **Babashka/SCI** | < 20 ms | Low | Limited library support, interpreted | Small to medium scripts, CLIs, simple tasks |\n\n*Table data synthesized from search queries on AWS Lambda cold starts, GraalVM, and Babashka.*\n\n### 2.2. Actionable Recommendations\n* **For CLIs and simple scripts**: Default to **Babashka**. Its near-instant startup and broad support for common libraries make it ideal.\n* **For performance-critical serverless functions**: Use **GraalVM**. The investment in build configuration pays off with minimal cold start latency.\n* **For traditional containerized services**: Use a modern JDK with **tiered compilation** and explore **Application Class-Data Sharing (AppCDS)** to reduce startup times on subsequent runs.\n\n## 3. Interactive Development vs. Production Reality\n\nThe \"REPL-Driven Development\" (RDD) workflow is a cornerstone of Clojure's productivity, but it becomes fragile without a disciplined approach to state management, leading to wasted time and frustrating debugging sessions.\n\n### 3.1. The Failure Modes of `tools.namespace`\nThe widely used `clojure.tools.namespace` library provides a `refresh` function to reload modified code without restarting the JVM [7]. However, this process is brittle:\n* **Inconsistent State**: A code change that throws an exception during reload can leave the application in a \"half-reloaded\" state, where some parts of the system have been stopped but not restarted [1]. This can lead to lost resource handles (e.g., socket connections) that can only be cleaned up by a full JVM restart [1].\n* **REPL Pollution**: A syntax error in any file can cause the entire reload to fail, often wiping out the helper functions and aliases defined in the developer's `user.clj` namespace, forcing a clumsy manual recovery [1].\n\n### 3.2. Bullet-Proofing the Reload Workflow with State Management Libraries\nTo solve this, the community has developed libraries that manage application state as an explicit, controllable system. These libraries provide a robust foundation for RDD.\n\n| Library | Philosophy | State Representation | Key Benefit |\n| :--- | :--- | :--- | :--- |\n| **Component** | State is a system of interdependent records. | A map of Clojure records. | Explicit dependency graph, good for complex systems. [6] |\n| **Mount** | State is attached to vars in namespaces. | Vars and namespaces. | Simpler, less boilerplate for smaller applications. [6] |\n| **Integrant** | State is defined declaratively by data. | Configuration map with multi-methods. | Addresses perceived limitations of Component, highly flexible. [6] |\n\nThese tools enable a reliable `(reset)` workflow that tears down the old system, reloads all code, and starts a new, clean system, all within the same JVM process [1]. This approach is foundational to maintaining high productivity and avoiding the pitfalls of a long-running, inconsistent REPL session [7].\n\n### 3.3. Remote Debugging\nClojure's REPL architecture allows connecting to a remote process, including staging or production environments [5]. This can be done via a socket server or more feature-rich tools like nREPL [6]. While incredibly powerful for live inspection, this practice requires extreme caution and robust security measures (e.g., SSH tunneling, network policies) to prevent unauthorized access.\n\n## 4. Concurrency and Deadlock Diagnostics\n\nDiagnosing concurrency issues like deadlocks, race conditions, and resource leaks in `core.async` or with Software Transactional Memory (STM) is notoriously difficult with traditional debugging methods.\n\n### 4.1. Common Pain Points\n* **`core.async` Channel Leaks**: Go-blocks that are parked on a channel that never receives a value can lead to silent resource leaks and thread pool exhaustion.\n* **Deadlock Diagnosis**: Identifying the cause of a deadlock often involves manual inspection of thread dumps, which is time-consuming and requires deep JVM expertise.\n\n### 4.2. Modern Tooling for Concurrency\n* **FlowStorm**: This advanced debugging tool provides visual tracing of code execution, which is invaluable for understanding complex concurrent interactions. It allows developers to step through execution flows and inspect data at each point, making it easier to spot issues like channel leaks [5] [10].\n* **JDK Mission Control (JMC) & Flight Recorder (JFR)**: These standard JDK tools can be used to profile a running application with low overhead, capturing detailed information about lock contention, thread states, and other concurrency-related events [11].\n* **`clj-async-profiler`**: In addition to CPU profiling, this tool can be configured to profile lock contention, providing flame graphs that pinpoint where threads are spending time waiting for locks [9].\n\n## 5. Java Interop Performance: Eliminating Reflection\n\nClojure's seamless Java interoperability is a key strength, but its reliance on reflection for dynamic method dispatch is a major performance trap.\n\n### 5.1. The Staggering Cost of Reflection\nWhen the Clojure compiler cannot determine the precise Java method to call at compile time, it emits a reflective call. This runtime lookup is significantly slower than a direct method invocation.\n\n| Code | Type Hint | Average Execution Time | Performance Gain | Source |\n| :--- | :--- | :--- | :--- | :--- |\n| `(.length x)` | None | 3007.2 ms (for 1M calls) | - | [12] |\n| `(.length ^String x)` | `^String` | 308.0 ms (for 1M calls) | **~10x** | [12] |\n| `(.charAt arg idx)` | None | 4.82 µs | - | [2] |\n| `(.charAt ^String arg idx)` | `^String` | 12.35 ns | **~390x** | [2] |\n\n### 5.2. A Practical Guide to Eliminating Reflection\nThe official guidance is to avoid premature optimization, but reflection warnings should always be addressed in performance-sensitive code [13] [12].\n\n1. **Enable `*warn-on-reflection*`**: Set `(set! *warn-on-reflection* true)` in your development environment and, most importantly, in your CI build. A build that produces reflection warnings should fail.\n2. **Add Type Hints**: Use metadata tags (`^String`, `^long`, `^doubles`) on function arguments, `let` bindings, and return values to provide the compiler with the necessary type information [12].\n ```clojure\n ;; Slow: reflection warning\n (defn slow-foo [s] (.charAt s 1))\n\n ;; Fast: no reflection\n (defn fast-foo [^String s] (.charAt s 1))\n ```\n3. **Use `:param-tags` for Overloaded Methods (Clojure 1.12+)**: For overloaded Java methods, a simple type hint may not be enough. The `:param-tags` metadata allows you to specify the exact method signature to resolve the ambiguity at compile time [12].\n4. **Optimize Primitive Math**: For high-performance numeric code, ensure that math operations are performed on primitive types. The correct pattern is to coerce values inside a `let` binding, not just hint the function argument [12].\n ```clojure\n ;; Slower: loop locals are boxed objects\n (defn foo [n]\n (loop [i 0] (if (< i n) (recur (inc i)) i)))\n\n ;; Faster: loop locals are primitive ints\n (defn fast-foo [n]\n (let [n (int n)]\n (loop [i (int 0)] (if (< i n) (recur (inc i)) i))))\n ```\n Using `unchecked-add`, `unchecked-multiply`, etc., can provide a small additional boost but sacrifices overflow checking and should be reserved for cases where truncating behavior is acceptable or performance is absolutely critical [12] [2].\n\n## 6. Dependency and Build Hygiene\n\nThe simplicity of adding dependencies with `tools.deps` can lead to a complex and fragile dependency graph over time, resulting in version conflicts, bloated artifacts, and Ahead-of-Time (AOT) compilation issues.\n\n### 6.1. Managing the Dependency Graph with `tools.deps`\n`tools.deps` is a dependency manager, not a full build tool [14]. It resolves transitive dependencies and constructs a classpath. Key practices for managing dependencies include:\n* **Resolving Conflicts**: When two libraries depend on different versions of a third library, `tools.deps` will pick one. To force a specific version, use the `:override-deps` key within an alias in your `deps.edn` file [15] [16].\n* **Auditing Dependencies**: Use a tool like `antq` in your CI pipeline to check for outdated dependencies and identify opportunities to upgrade.\n* **Monorepo Strategy**: For monorepos with multiple subprojects, a common pattern is to have a master `deps.edn` file at the root and use the `CLJ_CONFIG` environment variable to point the `clj` command to it, ensuring consistent dependency versions across the entire repository [14].\n\n### 6.2. AOT Compilation Pitfalls\nAOT compilation is required when using `gen-class` to generate Java classes from Clojure code [16]. However, AOT compiling an entire application is often an anti-pattern that can lead to larger artifacts and issues with GraalVM native compilation. The best practice is to AOT compile only the specific namespaces that require it. The `deps.edn` file can be configured to run this compilation as a preparation step for a library [16].\n\n### 6.3. Building Lean Uberjars\nThe community has developed tools that work with `tools.deps` to handle build tasks like creating uberjars. A typical pipeline involves:\n1. Using `tools.deps` to resolve the classpath.\n2. Using a build tool like `tools.build` (from the Clojure team) or `depstar` to compile necessary classes and package the source code and dependencies into a single executable JAR.\n\n## 7. Performance Profiling Playbook\n\nEffective performance tuning is impossible without accurate profiling. The adage \"premature optimization is the root of all evil\" holds true; you must measure first [2]. Fortunately, the Clojure ecosystem has excellent, low-overhead tools for this purpose.\n\n### 7.1. `clj-async-profiler`: The Go-To Profiler\n`clj-async-profiler` is the recommended starting point for any performance investigation [11]. It is an embedded profiler based on the high-precision, low-overhead async-profiler for Java [9].\n* **Key Features**: It can be added as a simple dependency, controlled programmatically, and used safely in production [9].\n* **Profiling Modes**: It supports multiple modes of analysis, generating interactive flame graphs for each:\n * **:cpu**: Shows where CPU time is being spent.\n * **:alloc**: Shows which functions are allocating the most objects on the heap. This is crucial for identifying sources of garbage collection (GC) pressure [17].\n * **:lock**: Shows where threads are contending for locks.\n\n### 7.2. The Trap of Laziness in Profiling\nLaziness can completely mislead profilers. A function that creates a lazy sequence may appear fast, while the function that later consumes it (forcing its realization) will be blamed for all the computational work [3]. When profiling, it is essential to use `doall` or other realizing functions to ensure the work happens where you expect it to.\n\n### 7.3. Memory Analysis Tools\n* **`clj-memory-meter`**: This library measures the deep memory footprint of a given Clojure object on the heap. A new `trace` feature allows instrumenting functions to report memory usage before and after invocation, helping to pinpoint an algorithm's peak memory requirement [17].\n* **Heap Dump Analysis**: For diagnosing memory leaks, standard JVM tools like `jstat`, VisualVM, and Eclipse MAT remain invaluable. They allow you to take a snapshot of the heap and analyze which objects are being retained [17].\n\n### 7.4. Benchmarking with `criterium`\nFor microbenchmarking specific functions, `criterium` is the industry standard. It is designed to handle the complexities of the JVM, such as JIT compilation and GC, to produce statistically sound measurements [2].\n\n## 8. Governance and Next Steps: A Checklist for Production Excellence\n\nTo ensure these improvements are lasting, they must be codified into team practices and automated in CI/CD pipelines.\n\n### 8.1. CI Gates and Policy Checklist\n- [ ] **Fail build on reflection warnings**: Add `(set! *warn-on-reflection* true)` to your build script.\n- [ ] **Run `antq` for outdated dependencies**: Add a step to check for and flag outdated libraries.\n- [ ] **Enforce a startup time budget**: For CLI tools or serverless functions, add a test that measures startup time and fails if it exceeds a defined threshold.\n- [ ] **Standardize on a state management library**: Mandate the use of Integrant, Mount, or Component for all new services.\n- [ ] **Adopt a standard for `ex-info`**: Require that all exceptions caught and re-thrown use `ex-info` with a consistent data map structure.\n\n### 8.2. Performance and Observability Dashboard\nEstablish a dashboard to track key production health metrics over time:\n* **Mean Time To Resolution (MTTR)**: Track how long it takes to resolve production incidents. Improvements in logging and error reporting should drive this number down.\n* **p95 Latency**: Monitor the 95th percentile response time for key API endpoints.\n* **Application Startup Time**: Track the cold start time for services.\n* **Uberjar/Docker Image Size**: Monitor the size of deployment artifacts to prevent bloat.\n\nBy systematically addressing these eight pain points, teams can harness the full power of Clojure while building robust, performant, and maintainable production systems.\n\n## References\n\n1. *\n    \n    My Clojure Workflow, Reloaded\n    \n  *. https://www.cognitect.com/blog/2013/06/04/clojure-workflow-reloaded\n2. *Clojure Speed Comparison: Evaluating the Performance of Clojure - Freshcode*. https://www.freshcodeit.com/blog/clojure-speed-evaluating-the-performance-of-clojure\n3. *Clojure's deadly sin - Clojure Goes Fast*. https://clojure-goes-fast.com/blog/clojures-deadly-sin/\n4. *Reloading Woes*. https://lambdaisland.com/blog/2018-02-09-reloading-woes\n5. *Why Clojure Developers Love the REPL So Much | by Flexiana | Medium*. https://medium.com/@flexianadevgroup/why-clojure-developers-love-the-repl-so-much-7a6dfda66287\n6. *Clojure - Programming at the REPL: Enhancing your REPL workflow*. https://clojure.org/guides/repl/enhancing_your_repl_workflow\n7. *REPL-Driven Development with Clojure | by Shubham Sharma | Medium*. https://medium.com/@ss-tech/repl-driven-development-with-clojure-f8ff9c54f780\n8. *On a Clojure/Clojurescript project, does it make sense to have dependencies declared on a \"shadow-cljs.edn\" and a \"deps.edn\" file? - Stack Overflow*. https://stackoverflow.com/questions/74227173/on-a-clojure-clojurescript-project-does-it-make-sense-to-have-dependencies-decl\n9. *clj-async-profiler - Clojure Goes Fast*. https://clojure-goes-fast.com/kb/profiling/clj-async-profiler/\n10. *Why Clojure? | Hacker News*. https://news.ycombinator.com/item?id=43137586\n11. *Clojure general performance profiling 2023? - Questions & Help / How to? - ClojureVerse*. https://clojureverse.org/t/clojure-general-performance-profiling-2023/10344\n12. *Clojure - Java Interop*. https://clojure.org/reference/java_interop\n13. *When, or why, should type hints be avoided? - Questions & Help / General Questions - ClojureVerse*. https://clojureverse.org/t/when-or-why-should-type-hints-be-avoided/3743\n14. *How to Effectively Use Deps & CLI? - Questions & Help / How to? - ClojureVerse*. https://clojureverse.org/t/how-to-effectively-use-deps-cli/4787\n15. *Deps and CLI Guide - Clojure*. https://japan-clojurians.github.io/clojure-site-ja/guides/deps_and_cli\n16. *Clojure - Deps and CLI Guide*. https://clojure.org/guides/deps_and_cli\n17. *Tracking memory usage with clj-memory-meter.trace - Clojure Goes Fast*. https://clojure-goes-fast.com/blog/tracking-memory-usage/","basis":[{"reasoning":"The report synthesizes information from official documentation, technical blogs, and community discussions to address common Clojure production issues. Specific performance benchmarks for Java interop reflection come directly from a Freshcode article and the official Clojure Java Interop guide. The analysis of memory leaks from lazy sequences and the utility of `clj-async-profiler` are supported by the \"Clojure Goes Fast\" blog. The discussion on fragile REPL workflows and the benefits of state management libraries like Integrant and Mount is based on a Cognitect blog post (\"My Clojure Workflow, Reloaded\") and official Clojure guides. Recommendations for dependency management using `tools.deps` are drawn from the \"Deps and CLI Guide\". The claims are consistently and specifically backed by the provided sources, leading to a high degree of confidence in the report's conclusions.","field":"content","citations":[{"title":"How to display better errors in clojure stacktraces? is this planned to be attacked on a new clojure version? - Clojure Q&A","url":"https://ask.clojure.org/index.php/8343/display-clojure-stacktraces-planned-attacked-clojure-version","excerpts":[]},{"title":"Why Clojure? | Hacker News","url":"https://news.ycombinator.com/item?id=43137586","excerpts":[]},{"title":"Exceptions in Clojure","url":"https://grishaev.me/en/clj-book-exceptions/","excerpts":[]},{"title":"How to improve Clojures error messages - Stack Overflow","url":"https://stackoverflow.com/questions/1756722/how-to-improve-clojures-error-messages","excerpts":[]},{"title":"Can jank beat Clojure's error reporting?","url":"https://jank-lang.org/blog/2025-03-28-error-reporting/","excerpts":[]},{"title":"GitHub - tonsky/clojure-plus: A project to improve experience of using Clojure stdlib","url":"https://github.com/tonsky/clojure-plus","excerpts":[]},{"title":"Clojure from the ground up: debugging","url":"https://aphyr.com/posts/319-clojure-from-the-ground-up-debugging","excerpts":[]},{"title":"Is clojure 1.9 improving error messages","url":"https://www.reddit.com/r/Clojure/comments/778tc2/is_clojure_19_improving_error_messages/","excerpts":[]},{"title":"Latest best thinking about Clojure on AWS Lambda? - Questions & Help / General Questions - ClojureVerse","url":"https://clojureverse.org/t/latest-best-thinking-about-clojure-on-aws-lambda/7100","excerpts":[]},{"title":"Reducing Clojure Lambda Cold Starts Part 1 - Baseline","url":"https://lambdastew.hashnode.dev/reducing-clojure-lambda-cold-starts-part-1-baseline","excerpts":[]},{"title":"Clojure in Google Cloud Run with Jib - Hannu Hartikainen","url":"https://hannuhartikainen.fi/blog/clojure-cloud-run/","excerpts":[]},{"title":"How do you diagnose the cause of slow (25min) app startup time? - Clojure Q&A","url":"https://ask.clojure.org/index.php/9357/how-do-you-diagnose-the-cause-of-slow-25min-app-startup-time","excerpts":[]},{"title":"Rust vs. JVM: Adjustments following organizational restructuring : r/rust","url":"https://www.reddit.com/r/rust/comments/1aytwhh/rust_vs_jvm_adjustments_following_organizational/","excerpts":[]},{"title":"Tricks to make Clojure(startup time) faster?","url":"https://clojureverse.org/t/tricks-to-make-clojure-startup-time-faster/1176","excerpts":[]},{"title":"Has anyone benchmarked cold start times for ...","url":"https://ask.clojure.org/index.php/8292/has-anyone-benchmarked-cold-start-times-for-clojure-lambda","excerpts":[]},{"title":"**question** what is the actual state of scala native? ...","url":"https://www.reddit.com/r/scala/comments/16yl4cj/question_what_is_the_actual_state_of_scala_native/","excerpts":[]},{"title":"AWS Lambda SnapStart - What, and Why - The Symphonium","url":"https://blog.symphonia.io/posts/2023-01-11_snapstart-what-why","excerpts":[]},{"title":"Why Clojure Developers Love the REPL So Much | by Flexiana | Medium","url":"https://medium.com/@flexianadevgroup/why-clojure-developers-love-the-repl-so-much-7a6dfda66287","excerpts":[]},{"title":"Clojure - Programming at the REPL: Enhancing your REPL workflow","url":"https://clojure.org/guides/repl/enhancing_your_repl_workflow","excerpts":[]},{"title":"\n    \n    My Clojure Workflow, Reloaded\n    \n  ","url":"https://www.cognitect.com/blog/2013/06/04/clojure-workflow-reloaded","excerpts":[]},{"title":"REPL-Driven Development with Clojure | by Shubham Sharma | Medium","url":"https://medium.com/@ss-tech/repl-driven-development-with-clojure-f8ff9c54f780","excerpts":[]},{"title":"Reloading Woes","url":"https://lambdaisland.com/blog/2018-02-09-reloading-woes","excerpts":[]},{"title":"Why should i use Mount or Component - Beginners","url":"https://clojureverse.org/t/why-should-i-use-mount-or-component/5826","excerpts":[]},{"title":"Clojuring the web application stack: Meditation One","url":"https://www.evalapply.org/posts/clojure-web-app-from-scratch/index.html","excerpts":[]},{"title":"Clojure - Java Interop","url":"https://clojure.org/reference/java_interop","excerpts":[]},{"title":"Type hinting in defrecord? - Questions & Help / How to? - ClojureVerse","url":"https://clojureverse.org/t/type-hinting-in-defrecord/9475","excerpts":[]},{"title":"Built-in function for Thread/sleep to avoid type hints - Clojure Q&A","url":"https://ask.clojure.org/index.php/12853/built-in-function-for-thread-sleep-to-avoid-type-hints","excerpts":[]},{"title":"Cuddly, Octo-Palm Tree: Notes on Optimizing Clojure Code: Type Hints","url":"https://cuddly-octo-palm-tree.com/posts/2022-02-27-opt-clj-7/","excerpts":[]},{"title":"When, or why, should type hints be avoided? - Questions & Help / General Questions - ClojureVerse","url":"https://clojureverse.org/t/when-or-why-should-type-hints-be-avoided/3743","excerpts":[]},{"title":"Refection warning even with type hinting - Clojure Q&A","url":"https://ask.clojure.org/index.php/14622/refection-warning-even-with-type-hinting","excerpts":[]},{"title":"Clojure Coding Guide","url":"https://grishaev.me/en/clojure-guide/","excerpts":[]},{"title":"Type hints getting ignored, reverting to java.lang.Object","url":"https://ask.clojure.org/index.php/10555/type-hints-getting-ignored-reverting-to-java-lang-object","excerpts":[]},{"title":"Try Clojure – An interactive tutorial in the browser","url":"https://news.ycombinator.com/item?id=30423856","excerpts":[]},{"title":"GitHub - clojure/tools.deps: Deps as data and classpath generation","url":"https://github.com/clojure/tools.deps","excerpts":[]},{"title":"How to Effectively Use Deps & CLI? - Questions & Help / How to? - ClojureVerse","url":"https://clojureverse.org/t/how-to-effectively-use-deps-cli/4787","excerpts":[]},{"title":"Deps and CLI Guide - Clojure","url":"https://japan-clojurians.github.io/clojure-site-ja/guides/deps_and_cli","excerpts":[]},{"title":"Clojure - Deps and CLI Guide","url":"https://clojure.org/guides/deps_and_cli","excerpts":[]},{"title":"How to manage package dependencies in a system built ...","url":"https://www.reddit.com/r/Clojure/comments/7jesu7/how_to_manage_package_dependencies_in_a_system/","excerpts":[]},{"title":"Organizing Clojure code - A real problem? - Beginners","url":"https://clojureverse.org/t/organizing-clojure-code-a-real-problem/7567","excerpts":[]},{"title":"On a Clojure/Clojurescript project, does it make sense to have dependencies declared on a \"shadow-cljs.edn\" and a \"deps.edn\" file? - Stack Overflow","url":"https://stackoverflow.com/questions/74227173/on-a-clojure-clojurescript-project-does-it-make-sense-to-have-dependencies-decl","excerpts":[]},{"title":"Finding Clojure: New Beginnings - The Rattlin' Blog","url":"https://rattlin.blog/finding-clj-new-beginnings.html","excerpts":[]},{"title":"Clojure Speed Comparison: Evaluating the Performance of Clojure - Freshcode","url":"https://www.freshcodeit.com/blog/clojure-speed-evaluating-the-performance-of-clojure","excerpts":[]},{"title":"clj-async-profiler - Clojure Goes Fast","url":"https://clojure-goes-fast.com/kb/profiling/clj-async-profiler/","excerpts":[]},{"title":"Clojure's deadly sin - Clojure Goes Fast","url":"https://clojure-goes-fast.com/blog/clojures-deadly-sin/","excerpts":[]},{"title":"Clojure general performance profiling 2023? - Questions & Help / How to? - ClojureVerse","url":"https://clojureverse.org/t/clojure-general-performance-profiling-2023/10344","excerpts":[]},{"title":"Tracking memory usage with clj-memory-meter.trace - Clojure Goes Fast","url":"https://clojure-goes-fast.com/blog/tracking-memory-usage/","excerpts":[]},{"title":"Profiling tool for Clojure?","url":"https://stackoverflow.com/questions/2974916/profiling-tool-for-clojure","excerpts":[]},{"title":"Top 7 Clojure Static Code Analysis Tools","url":"https://daily.dev/blog/top-7-clojure-static-code-analysis-tools","excerpts":[]}]}],"type":"text"}}